<?php

define('MESSAGE_NODE_INSERT','create_node');
define('MESSAGE_NODE_UPDATE','update_node');
define('MESSAGE_COMMENT_INSERT','create_comment');
define('MESSAGE_USER_INSERT','user_register');
define('MESSAGE_OG_USER','og_user_membership');
define('MESSAGE_OG_USER_REQUEST','og_user_membership_request');
define('MESSAGE_GROUPS_FIELD','field_node_groups_ref');
define('MESSAGE_NODE_FIELD','field_node_ref');
define('MESSAGE_FOLLOWERS_FIELD','field_follower');
define('MESSAGE_COMMENT_FIELD','field_comment_ref');

/**
 * @file
 * Collabco message feature.
 */

include_once('collabco_message_feature.features.inc');

/**
 * Implements hook_block_info().
 */
function collabco_message_feature_block_info() {
  $blocks = array(
    'followers' => array(
      'info' => t('Followers'),
    ),
  );
  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function collabco_message_feature_block_view($delta='') {
  switch($delta) {
    case 'followers' :
      $block = collabco_message_feature_build_followers_block();
      return $block;
  }
} 

/**
 * Implements hook_menu_alter().
 */
function collabco_message_feature_menu_alter(&$items) {
  $items['user/%user/message-subscribe']['title'] = 'Following';
}

/**
 * Implements hook_node_view_alter().
 */
function collabco_message_feature_node_view_alter(&$build) {
  // Only allow subscription if comments are open.
  if (($build['#node']->comment !== '2')) {
    unset($build['links']['flag']['#links']['flag-follow_node']);
  }
  // Only show group subscription if this is actually a group.
  if (empty($build['#node']->{OG_GROUP_FIELD})) {
    unset($build['links']['flag']['#links']['flag-follow_og']);
  }
  // Hide normal follow for groups, we dont follow them as nodes.
  else {
    unset($build['links']['flag']['#links']['flag-follow_node']);
  }
}

/**
 * Implements hook_node_insert().
 */
function collabco_message_feature_node_insert($node) {
  collabco_message_feature_node_message($node, MESSAGE_NODE_INSERT);
  // Allways follow own content.
  collabco_message_feature_follow_node($node->uid, $node->nid);
}


/**
 * Implements hook_node_update().
 */
function collabco_message_feature_node_update($node) {
  global $user;
  // Delete any earlier update messages by this user, so the activity isn't 
  // filled with multiple edits of one thing.
  collabco_message_feature_delete_matching_messages('node', $node, $user->uid, MESSAGE_NODE_UPDATE); 
  // Update existing message status.
  collabco_message_feature_update_message_status('node', $node);
  //Create message.
  collabco_message_feature_node_message($node, MESSAGE_NODE_UPDATE);
}

/**
 * Implements hook_comment_insert().
 */
function collabco_message_feature_comment_insert($comment) {
  $account = user_load($comment->uid);
  $node = node_load($comment->nid);

  if ($groups = og_get_entity_groups('node', $node)) {
    $gids = $groups['node']; 
  }

  $arguments['!groups'] = array(
    'callback' => 'collabco_message_feature_group_list',
    'pass message' => TRUE,
  );

  $message = message_create(MESSAGE_COMMENT_INSERT, array('arguments' => $arguments), $account);
  // Save reference to the node in the node reference field, and the
  // "publish" state (i.e. if the node is published or unpublished).
  $message_wrapper = entity_metadata_wrapper('message', $message);
  $message_wrapper->{MESSAGE_NODE_FIELD}->set($node);
  $message_wrapper->{MESSAGE_COMMENT_FIELD}->set($comment);
  if (!empty($gids)) {
    $message_wrapper->{MESSAGE_GROUPS_FIELD}->set($gids);
  }

  // The message should be published only if the node and the comment are
  // both published.
  $published = $node->status && $comment->status;
  $message_wrapper->field_published->set($published);
  $message_wrapper->save();

  collabco_message_feature_send_notifications('comment', $comment, $message);

  // Allways follow content after you comment on it.
  $flag = flag_get_flag('follow_node') or die('no "follow_node" flag defined');
  $account = user_load($comment->uid);
  $flag->flag('flag', $comment->nid, $account);
}

/**
 * Implements hook_comment_update().
 */
function collabco_message_feature_comment_update($comment) {
  collabco_message_feature_update_message_status('comment', $comment);
}

/**
 * Implements hook_user_insert()
 */
function collabco_message_feature_user_insert(&$edit, $account, $category) {
  $message = message_create('user_register', array(), $account);
  $message_wrapper = entity_metadata_wrapper('message', $message);
  $message_wrapper->field_published->set($account->status);
  $message_wrapper->save();

  $subscribe_options = array();
  $notify_options = array();
  $entity_type = 'user';
  // Notify all community moderators.
  $role = user_role_load_by_name("Community Moderator");
  $query = 'SELECT DISTINCT(ur.uid) 
      FROM {users_roles} AS ur
      WHERE ur.rid IN (:rids)';
  $result = db_query($query, array(':rids' => array($role->rid)));
  foreach($result as $row) {
    $subscribe_options['uids'][$row->uid] = array('notifiers' => array('email'));
  }

  collabco_message_feature_send_notifications('user', $account, $message, $notify_options, $subscribe_options); 
}

/**
 * Implements hook_og_membership_insert().
 */
function collabco_message_feature_og_membership_insert($og_membership) {
  if ($og_membership->group_type != 'node') {
    // For simplicity we operate only on membership with node groups.
    return;
  }
  if (!$og_membership->etid) {
    // Don't capture membership of anonymous user, that might be caused
    // when using Devel generate.
    return;
  }
  if ($og_membership->entity_type != 'user') {
    // We ignore content, as node insert/update hooks take care of that.
    return;
  }

  if ($og_membership->state != OG_STATE_ACTIVE ) {
    // Membership isn't active, send a message to group moderators.
    $message_type = MESSAGE_OG_USER_REQUEST;
    collabco_message_feature_og_user_message($og_membership, $message_type);
  }
  // Create a normal user membership message. It may be initially unpublished.
  $message_type = MESSAGE_OG_USER;
  collabco_message_feature_og_user_message($og_membership, $message_type);

  // Allways follow a group after you comment on it.
  $flag = flag_get_flag('follow_og') or die('no "follow_og" flag defined');
  $account = user_load($og_membership->etid);
  $flag->flag('flag', $og_membership->gid, $account);
}

function collabco_message_feature_og_membership_update($og_membership) {
  if ($og_membership->group_type != 'node') {
    // For simplicity we operate only on membership with node groups.
    return;
  }
  if (!$og_membership->etid) {
    // Don't capture membership of anonymous user, that might be caused
    // when using Devel generate.
    return;
  }
  if ($og_membership->entity_type != 'user') {
    // We ignore content, as node insert/update hooks take care of that.
    return;
  }

  //collabco_message_feature_update_user_message_status('node', $node);
}

/**
 * Create messages for user group memberships.
 */
function collabco_message_feature_og_user_message($og_membership, $message_type) {
  $group = node_load($og_membership->gid);
  $account = user_load($og_membership->etid);

  if ($message_type == MESSAGE_OG_USER) {
    // Dont add public messages when users join private groups.
    $group_wrapper = entity_metadata_wrapper('node', $group);
    if (($group_wrapper->__isset(OG_ACCESS_FIELD)) && ($group_wrapper->{OG_ACCESS_FIELD}->value() == '1')) {
      return;
    }
  }
  $message = message_create($message_type, array(), $account);
  $message_wrapper = entity_metadata_wrapper('message', $message);
  $message_wrapper->{MESSAGE_GROUPS_FIELD}->set(array($og_membership->gid));
  if ($og_membership->state === OG_STATE_ACTIVE) {
    $published = $group->status;
  }
  else {
    $published = FALSE;
  }
  $message_wrapper->field_published->set($published);
  $message_wrapper->save();

  // Notify moderators. There should be a variable to set or unset this at some stage.
  $notify_options = array();
  $subscribe_options = array();
  if ($message_type === MESSAGE_OG_USER_REQUEST) {
    // Notify group admins.
    $uids = collabco_message_feature_get_role_users($og_membership->gid, 'administrator member');
    $uids[$group->uid] = $group->uid;
    foreach($uids as $key => $uid) {
      $subscribe_options['uids'][$uid] = array('notifiers' => array('email'));
    }
  }
  collabco_message_feature_send_notifications('user', $account, $message, $notify_options, $subscribe_options); 
}

function collabco_message_feature_get_role_users($gid, $role_name) {
  // Get role ids for all group types. 
  $query = db_select('og_role', 'ogr')
    ->fields('ogr', array('rid'))
    ->condition('name', $role_name, '=')
    ->execute();
  foreach($query as $row) { 
    $rids[$row->rid] = $row->rid;
  }
  
  // Get users with the role in the group.
  $query = db_select('og_users_roles', 'ogur')
    ->fields('ogur', array('uid'))
    ->condition('gid', $gid, '=')
    ->condition('rid', $rids, 'IN')
    ->execute();
  $uids = array();
  foreach($query as $row) {
    $uids[$row->uid] = $row->uid;
  }
  return $uids;
}

/**
 * Update the "published" field in the message entity, when it changes in the
 * related entity.
 *
 * @param $entity_type
 *   The entity type (node or comment).
 * @param $entity
 *   The entity object.
 */
function collabco_message_feature_update_message_status($entity_type, $entity) {
  if ($entity->status == $entity->original->status) {
    // status didn't change.
    return;
  }

  $messages = collabco_message_feature_get_matching_messages($entity_type, $entity);
  foreach ($messages as $mid => $message) {
    $message_wrapper = entity_metadata_wrapper('message', $mid);
    // If comment status changed, we still need to check the node as-well.
    if ($entity_type == 'comment') {
      $node = node_load($entity->nid);
      $status = intval($entity->status && $node->status);
    }
    else {
      // The entity is the node.
      $status = $entity->status;
    }
    if ($message_wrapper->field_published->value() != $status) {
      // Status changed, so update the message entity.
      $message_wrapper->field_published->set($status);
      $message_wrapper->save();
    }
  }
}

/**
 * Update the "published" field in the message entity, when it changes in the
 * related entity.
 *
 * @param $entity_type
 *   The entity type (node or comment).
 * @param $entity
 *   The entity object.
 */
function collabco_message_feature_update_memberhip_message_state($account, $message_type, $gid) {
  if ($og_membership->state == $og_membership->original->state) {
    // status didn't change.
    return;
  }

  $messages = collabco_message_feature_get_matching_messages(NULL, NULL, $account, $message_type, $gid);
  foreach ($messages as $mid => $message) {
    $message_wrapper = entity_metadata_wrapper('message', $mid);
    // If comment status changed, we still need to check the node as-well.
    if ($entity_type == 'comment') {
      $node = node_load($entity->nid);
      $status = intval($entity->status && $node->status);
    }
    else {
      // The entity is the node.
      $status = $entity->status;
    }
    if ($message_wrapper->field_published->value() != $status) {
      // Status changed, so update the message entity.
      $message_wrapper->field_published->set($status);
      $message_wrapper->save();
    }
  }
}

/**
 * Find existing messages referencing an entity, or with a user, group or
 * message type.
 *
 * @return array().
 */
function collabco_message_feature_delete_matching_messages($entity_type = NULL, $entity = NULL, $uid = NULL, $message_type = NULL, $gid = NULL) {
  $messages = collabco_message_feature_get_matching_messages($entity_type, $entity, $uid, $message_type, $gid); 
  foreach ($messages as $mid => $message) {
    $message_wrapper = entity_metadata_wrapper('message', $mid);
    $message_wrapper->delete();
  }
}

/**
 * Find existing messages referencing an entity, or with a user, group or
 * message type.
 *
 * @return array().
 */
function collabco_message_feature_get_matching_messages($entity_type = NULL, $entity = NULL, $uid = NULL, $message_type = NULL, $gid = NULL) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'message');

  if (!empty($entity) && !empty($entity_type)) {
    list($id) = entity_extract_ids($entity_type, $entity);
    // Comment or node ref field.
    $field_name = 'field_' . $entity_type . '_ref';
    $query->fieldCondition($field_name, 'target_id',  $id, '=');
  }

  // Specific user if required.
  if (!empty($uid)) {
    $query->propertyCondition('uid', $uid);
  }

  // Find specific message type if required.
  if (!empty($message_type)) {
    $query->entityCondition('bundle', $message_type, '=');
  }

  // Find specific gid if required.
  if (!empty($gid)) {
    $query->fieldCondition(MESSAGE_GROUPS_FIELD, 'target_id',  $gid, '=');
  }
  $result = $query->execute();

  if (!empty($result['message'])) {
    return $result['message'];
  }

  return array();
}

function collabco_message_feature_node_message($node, $message_type) {
  
  $node_wrapper = entity_metadata_wrapper('node', $node);
  if (($node_wrapper->__isset(OG_ACCESS_FIELD)) && ($node_wrapper->{OG_ACCESS_FIELD}->value() == '1')) {
    // Dont add messages for the creation of private groups.
    return;
  }
  $groups = og_get_entity_groups('node', $node);
  // Create a "Post in group" message. We don't use a token replacement
  // here as it needs to get the data from multiple values of the field.
  // Furthermore, this replacement probably doesn't make sense outside of
  // this message-type context, so we don't want to add another token,
  // that will not be used.
  $arguments['!groups'] = array(
    'callback' => 'collabco_message_feature_group_list',
    'pass message' => TRUE,
  );

  $message = message_create($message_type, array('arguments' => $arguments, 'uid' => $node->uid));
  $message_wrapper = entity_metadata_wrapper('message', $message);
  $message_wrapper->{MESSAGE_NODE_FIELD}->set($node);
  $message_wrapper->field_published->set($node->status);
  if (!empty($groups['node'])) {
    $message_wrapper->{MESSAGE_GROUPS_FIELD}->set($groups['node']);
  }
  $message_wrapper->save();

  collabco_message_feature_send_notifications('node', $node, $message);
}

function collabco_message_feature_send_notifications($entity_type, $entity, $message, $notify_options = array(), $subscribe_options = array()) {
  // Send email subscriptions if they are enabled.
  if (module_exists('message_subscribe')) {
    message_subscribe_send_message($entity_type, $entity, $message, $notify_options, $subscribe_options);
  }
}

/**
 * Message callback; Show a comma separated list of groups.
 *
 * @param $message
 *   The message entity.
 */
function collabco_message_feature_group_list(Message $message) {
  $message_wrapper = entity_metadata_wrapper('message', $message);
  $items = array();
  foreach ($message_wrapper->{MESSAGE_GROUPS_FIELD}->value() as $node) {
    if (!node_access('view', $node)) {
      // User doesn't have access to view the group.
      continue;
    }
    $url = entity_uri('node', $node);
    $label = entity_label('node', $node);
    $items[] = l($label, $url['path'], $url['options']);
  }
  if (!empty($items))
  return t('in ') . implode(', ', $items);
}

/**
 * Sets node follow flags for a user.
 */
function collabco_message_feature_follow_node($uid, $nid) {
  $flag = flag_get_flag('follow_node') or die('no "follow_node" flag defined');
  $account = user_load($uid);
  $flag->flag('flag', $nid, $account);
}

/**
 * Returns flag markup if a flag available for the current entity.
 */
function collabco_message_feature_flag_links() {
  switch (arg(0)) {
    case 'node' :
      if (arg(1) === 'add') {
        // No flags for node add page;
        return;
      }
      $flag_name = 'follow_node';
      $entity_id = arg(1);
      break;
    case 'taxonomy' :
      $flag_name = 'follow_term';
      $entity_id = arg(2);
      break;
    case 'user' :
      $flag_name = 'follow_user';
      $entity_id = arg(1);
      break;
    default : 
      return;
  }
  return flag_create_link($flag_name, $entity_id);
}

/**
 * Returns flag markup if a flag available for the current entity.
 */
function collabco_message_feature_og_flag_links() {
  if ($group = og_context()) {
    return flag_create_link('follow_og', $group['gid']);
  }
}

/**
 * Implements hook_collabco_integration().
 */
function collabco_message_feature_collabco_integration() {
  // Add links to views if a module wants to do that.
  return array(
    'collabco_message_feature' => array(
      'views' => array(
        'recent_activity' => array(
          'group_integration_block' => array(
            'tag_filter' => array(
              'relationship' => MESSAGE_NODE_FIELD . '_target_id',
            ),
          ),
          'user_integration_block' => array(
            'tag_filter' => array(
              'relationship' => MESSAGE_NODE_FIELD . '_target_id',
            ),
          ),
        ),
      ),
    ),
  );
}

function collabco_message_feature_build_followers_block() {
  global $user;
  $page_uid = $user->uid;
  $entity_type = 'node';
  $uids = array();
  $og_context = og_context();
  $flags = flag_get_flags();

  // Get all users following current group.
  //if ($og_context['group_type'] === $entity_type) {
    //$entity_id = $og_context['gid'];
    //$query = db_select('flagging', 'f')
    //->fields('f', array('uid'))
    //->condition('entity_type', $entity_type, '=')
    //->condition('fid', $flags['follow_og']->fid, '=')
    //->condition('entity_id', $entity_id, '=');
    //$result = $query->execute();
    ////dpm($result);
    
    //foreach ($result as $row) {
      //$uids[$row->uid] = $row->uid;
    //}
  //}

  // Get all users following current node.
  if ($node = menu_get_object('node', 1)) {
    // Get all users following current node.
    $entity_type = 'node';
    $query = db_select('flagging', 'f')
    ->fields('f', array('uid'))
    ->condition('entity_type', $entity_type, '=')
    ->condition('fid', $flags['follow_node']->fid, '=');
    //->condition('entity_id', $node->nid, '=');
    $result = $query->execute();

    foreach ($result as $row) {
      $uids[$row->uid] = $row->uid;
    }
  }

  // Load user pictures of followers.
  $user_pics = '';
  foreach ($uids as $uid) {
    $account = user_load($uid);
    $user_pics .= theme('user_picture', array('account' => $account));
  }

  if (!empty($user_pics)) {
    $block = array();
    $block['og_context'] = $og_context ;
    $block['content'] = array(
      '#type' => 'container',
      '#attributes' => array('class' => array('followers')),
      'title' => array(
        '#type' => 'markup',
        '#markup' => '<span class="following-label">' . t('Following this content:') . '</span>',
        '#weight' => 0,
      ),
      'follower-strip' => array(
        '#type' => 'container',
        '#attributes' => array('class' => array('followers')),
        '#weight' => 2,
        'user_pics' => array(
          '#type' => 'markup',
          '#markup' => $user_pics,
        ),
      ),
    );
  }
  return $block;
}

function collabco_message_feature_form_node_form_alter(&$form, &$form_state, $form_id) { // Add user autocomplete field.
  $form['#submit'][] = 'collabco_message_feature_custom_submit';
  $form['add_followers'] = array(
    '#type' => 'textfield',
    '#title' => t('Include users:'),
    '#description' => t('Add users, separated by commas'),
    '#autocomplete_path' => "collabco_message_feature/user/autocomplete/{$form['nid']['#value']}",
    '#weight' => -50,
  );
}

function collabco_message_feature_custom_submit($form, &$form_state) {
  $flag = flag_get_flag('follow_node') or die('no "follow_node" flag defined');
  $string = $form['add_follow']['#value'];
  $user_strings = drupal_explode_tags($string);
  $skip_permission_check = FALSE;
  foreach ($user_strings as $user_string) {
    $uid = filter_var($user_string, FILTER_SANITIZE_NUMBER_INT);
    $account = user_load($uid);
    $flag->flag('flag', $form['nid']['#value'], $account, $skip_permission_check);
  }
}

/**
 * Implements hook_menu().
 */
function collabco_message_feature_menu() {
  $items = array();

  $items['collabco_message_feature/user/autocomplete/%'] = array(
    'title' => 'User Autocomplete',
    'page callback' => 'collabco_message_feature_user_autocomplete_callback',
    'page arguments' => array(3),
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

function collabco_message_feature_user_autocomplete_callback($entity_id, $string) {
  $matches = array();
  $args = func_get_args();

  // The user enters a comma-separated list of tags. We only autocomplete the last tag.
  $users_typed = drupal_explode_tags($string);
  $user_last = drupal_strtolower(array_pop($users_typed));
  if (!empty($user_last)) {
    $prefix = count($users_typed) ? implode(', ', $users_typed) . ', ' : '';
  }
  else {
    // The user enters a single tag.
    $prefix = '';
    $user_last = $string;
  }

  $matches = array();
  // Return all for empty values.
  $query = db_select('realname', 'r')
    ->fields('r', array('uid', 'realname'))
    ->condition('realname', db_like($user_last) . '%', 'like');
  $result = $query->execute();

  // Save the query to matches.
  foreach ($result as $row) {
    if ($row->realname !== '') {
      $key = $row->realname . " ($row->uid)";
      // Strip things like starting/trailing white spaces, line breaks and tags.
      $key = preg_replace('/\s\s+/', ' ', str_replace("\n", '', trim(decode_entities(strip_tags($key)))));
      // Names containing commas or quotes must be wrapped in quotes.
      if (strpos($key, ',') !== FALSE || strpos($key, '"') !== FALSE) {
        $key = '"' . str_replace('"', '""', $key) . '"';
      }
      $matches[$prefix . $key ] = $prefix . $key;
    }
  }
  // Return the result to the form in json.
  drupal_json_output($matches);
}
